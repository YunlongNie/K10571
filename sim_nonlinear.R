library(dplyr)
library(ggplot2)
library(fda)
#  simulation two  
# all the g's are nonlinear, generated by splines

# set the levels for k and m
klevel = 3
mlevel = 10
# set the upper limit for t 
xlimt = 10
# generate a data.frame with slope and intercept for each k and m level 
data_km = expand.grid(k=1:klevel,m=1:mlevel)

spline_basis=create.bspline.basis(rangeval=c(0,xlimt),nbasis=5,norder=4)
E = inprod(spline_basis,spline_basis)
coef_list = lapply(1:mlevel, function(x){
lapply(1:klevel, function(y){
coef_m = rnorm(spline_basis$nbasis)
coef_m = coef_m/as.numeric(sqrt(coef_m%*%E%*%coef_m))
coef_m
})%>%do.call(cbind,.)
})



# I create a data frame in order to plot all the g functions for each m 

flim = function(m,k){
t = seq(0,xlimt,len=1000) # eval each line at 1000 equal spaced time points 
fd_temp = fd(coef_list[[m]][,k],spline_basis)
data.frame(m=m, k=k,value = eval.fd(t,fd_temp)%>%as.numeric, t=t)
}
library(ggplot2)
limd = mapply(flim,m=data_km$m, k=data_km$k,SIMPLIFY=FALSE)%>%do.call(rbind.data.frame,.)

ggplot(limd)+geom_line(aes(x=t,y=value,color=factor(k)))+facet_wrap(~m, scales="free")

## set the true value for k and t 
ttrue = 5
ktrue = 1
sigma_noise = 1

# fytrue is a function with input as the true k and t and output the true value of y
fytrue= function(ttrue,ktrue){
coef_k = lapply(coef_list, function(x) x[,ktrue])%>%do.call(cbind,.)
mfd_k = fd(coef_k, spline_basis)
eval.fd(ttrue, mfd_k)%>%as.numeric
}

# obtain the observed value of y with some noise 
yobs = fytrue(ttrue,ktrue)+rnorm(length(mlevel), sd=sigma_noise)

# loss function with input as any t and k and output as the square differences between the observed and fitted value (a length of m vector)

loss = function(y,t,k){
	
	(y-fytrue(t,k))^2

}

##  losst give the mean square differences or errors
losst = function(t,k) {
	mean((loss(yobs,t,k))^2)
}

## we can evaluate the loss function surface

settings = expand.grid(t=seq(0,10,len=20), k=1:3)
res = mapply(t=settings$t,k=settings$k, losst)
settings$res = res

head(settings)
ggplot(settings,aes(x=t,group=factor(k),color=factor(k),y=res))+geom_line()+geom_vline(xintercept = ttrue,col=4)+ggtitle(sprintf("true t: %s; true k: %s", ttrue, ktrue))




#  given a different value of t 
ttrue = 6
ktrue = 2
yobs = fytrue(ttrue,ktrue)+rnorm(length(mlevel))
res = mapply(t=settings$t,k=settings$k, losst)
settings$res = res
p0 = ggplot(settings,aes(x=t,group=factor(k),color=factor(k),y=res))+geom_line()+geom_vline(xintercept = ttrue,col=4)+theme_bw()+theme(legend.position = "none")+ggtitle('the loss function')
ggplot(settings%>%dplyr::filter(t<2),aes(x=t,group=factor(k),color=factor(k),y=res))

#MCMC
## set the initial vaue for the mcmc 
t0=2;k0=2;
meantk0 = fytrue(t0,k0)
l0=sum(dnorm(yobs,mean=meantk0,sd=1,log=T))
t_save = c()
k_save = c()
meantk0 = fytrue(t0,k0)
for (i in 1:1e4){
t1= runif(1,0,xlimt);k1= sample(1:3,1,replace=F)
meantk1 = fytrue(t1,k1)
l1=sum(dnorm(yobs,mean=meantk1,sd=1,log=T))
a = runif(1,0,1)
if(a<min(1,exp(l1-l0))) {t0=t1;k0=k1;l0=l1}
t_save = c(t_save,t0)
k_save = c(k_save,k0)
}

tpost = tail(t_save,1e3)
kpost = tail(k_save,1e3)
p1=  data.frame(t=tpost,k=kpost)%>%ggplot(aes(x=tpost))+stat_density(alpha=0.3, aes(fill=factor(k)))+facet_wrap(~k)+geom_vline(xintercept = ttrue,col=4)+ggtitle(sprintf('Posterior density for t conditional on k; \ntrue t: %s; true k: %s', ttrue, ktrue))+theme_bw()
p2 = data.frame(t=tpost,k=kpost)%>%ggplot(aes(x=tpost))+stat_density(alpha=0.3)+ggtitle('Posterior density for t accross \nall k')+geom_vline(xintercept = ttrue,col=4)+theme_bw()
p3 = data.frame(t=tpost,k=kpost)%>%ggplot(aes(x=factor(kpost), fill=factor(kpost)))+geom_histogram(stat="count")+ggtitle('Posterior histogram for k')+theme_bw()+theme(legend.position = "none")
library(gridExtra)
grid.arrange(p1,grid.arrange(p2,p3,p0,nrow=1),nrow=2)


